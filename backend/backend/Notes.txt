Program starts from Main function. 
Startup.css file is very important because it is used to register services and configure middleware. 
The sequence of registering services is not important but sequence of middleware is important.
By default, request generated by a browser is a get request i.e. to read resource.
[Route("[controller]")] can be changed to the shape you want i.e. we can change it as [Route("api/[controller]")]. But this change should also be reflected in launchsettings.json file as "launchUrl": "api/weatherforecast" otherwise application will 
show page not found error
Http Get request maps to the controller with [HttpGet] attribute. If there are multiple methods with no [HttpGet] or multiple methods having [HttpGet] the following error may be thrown: AmbiguousMatchException: The request matched multiple endpoints.
===============
DBContext relates to database while DBSet relates to table. 
The class that has been derived from DbContext must be added in services. Microsoft.EntityFrameworkCore and Microsoft.EntityFrameworkCore.SqlServer does not ship with dotnetcore so have to install it using NuGet package manager. 
After these packages you have to install dotnet-ef tool using dotnet tool install --global dotnet-ef at terminal prompt
All these installed package references must be present in .csproj file or you can add them manually
You can add migrations through dotnet ef migrations add MigrationName and then you can update database using dotnet ef database update  you can use --no-build switch to update database without building application
DTOs are used to decouple client from internal implementation. To hide properties that clients are not supposed to view. and to avoid 'over posting' vulnerabilities.

For HttpPatch we need to install Microsoft.aspnetcore.mvc.newtonsoftjson package from nuget package manager.

Using the try catch block for error handling has some troubles:
1. It calls for repitition of try catch blocks throughout our application.
2. It will show the same message for development and production environment.

So it is better to handle exception globally by using built in or own middleware.

Steps to create a new structure (all steps)
1. Make a model class.
2. Decorate fields with data annotations like required etc.
3. Add the class in DataContext class
4. Create a migration on terminal Developer PowerShell as dotnet ef migrations migrationName
5. Update database on terminal as dotnet ef database update
6. Create a repository interface IUserRepository
7. Create a user repository and implement the interface.
8. Add the interface in iunitofwork to get it accessible in controllers.
9. Make necessary changes in unitofwork.cs
10. Add a controller to use the functionality.
11. Create required DTOs to be exposed to end user.

Sensitive information should not be stored in source code because developers can get the key from there which is not recommended in some cases.
1. We can ignore file from GIT (not a good practice because file being ignored may contain other information too).
2. Keep in environment variable: Not encrypted, out of source control, production/development. Application needs restart.
3. Keep in some other file (Secret manager tool): Not encrypted, out of source control, production/development.
4. Keep in database in encrypted form
5. Keep in online Azure Vault

We can set environment variable by prefixing it with DOTNET_ or ASPNETCORE_ and on command prompt as setx ASPNETCORE_AppSettings__Key "This is my key" 
Use double __ before the Key. You can refer to StudyMash video 45 for further details

Database password should also be moved to some secret place.